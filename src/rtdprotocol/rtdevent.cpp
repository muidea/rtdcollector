//
//
//    This software is provided 'as-is', without any express or implied
//    warranty. In no event will the authors be held liable for any
//    damages arising from the use of this software.
//
//    Generated by mupcompiler.
//
//    Author: muidea@gmail.com
//
//
#include "rtdevent.h"

namespace RtdPrococol {

RtdEvent::RtdEvent()
{
}

RtdEvent::~RtdEvent()
{
}

bool RtdEvent::encode(void* pBuffPtr, UINT32 uBuffSize, UINT32& uRemainSize) const
{
    bool bRet = true;
    UINT32 uPacketSize = calcSize();
    if (uBuffSize < uPacketSize) {
        return false;
    }
    uRemainSize = uBuffSize;
    bRet = MUPProtocol::encode(uPacketSize, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::encode(_ownerID, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::encode(_timeStamp, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::encode(_eventID, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    return bRet;
}

bool RtdEvent::decode(const void* pDataPtr, UINT32 uDataSize, UINT32& uRemainSize)
{
    bool bRet = true;
    UINT32 uPacketSize = 0;
    uRemainSize = uDataSize;
    bRet = MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, uPacketSize, uRemainSize);
    if (!bRet || (uPacketSize > uDataSize)) {
        return bRet;
    }

    MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, _ownerID, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, _timeStamp, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, _eventID, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    uRemainSize = uDataSize - uPacketSize;
    return bRet;
}

UINT32 RtdEvent::calcSize() const
{
    UINT32 uRet = sizeof(UINT32);
    uRet += MUPProtocol::getSize(_ownerID);
    uRet += MUPProtocol::getSize(_timeStamp);
    uRet += MUPProtocol::getSize(_eventID);

    return uRet;
}

RtdEventInfo::RtdEventInfo()
{
}

RtdEventInfo::~RtdEventInfo()
{
}

bool RtdEventInfo::encode(void* pBuffPtr, UINT32 uBuffSize, UINT32& uRemainSize) const
{
    bool bRet = true;
    UINT32 uPacketSize = calcSize();
    if (uBuffSize < uPacketSize) {
        return false;
    }
    uRemainSize = uBuffSize;
    bRet = MUPProtocol::encode(uPacketSize, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::encode(_eventVector, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    return bRet;
}

bool RtdEventInfo::decode(const void* pDataPtr, UINT32 uDataSize, UINT32& uRemainSize)
{
    bool bRet = true;
    UINT32 uPacketSize = 0;
    uRemainSize = uDataSize;
    bRet = MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, uPacketSize, uRemainSize);
    if (!bRet || (uPacketSize > uDataSize)) {
        return bRet;
    }

    MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, _eventVector, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    uRemainSize = uDataSize - uPacketSize;
    return bRet;
}

UINT32 RtdEventInfo::calcSize() const
{
    UINT32 uRet = sizeof(UINT32);
    uRet += MUPProtocol::getSize(_eventVector);

    return uRet;
}


}

