//
//
//    This software is provided 'as-is', without any express or implied
//    warranty. In no event will the authors be held liable for any
//    damages arising from the use of this software.
//
//    Generated by mupcompiler.
//
//    Author: muidea@gmail.com
//
//
#include "rtdvalue.h"

namespace RtdPrococol {

RtdTag::RtdTag()
{
}

RtdTag::~RtdTag()
{
}

bool RtdTag::encode(void* pBuffPtr, UINT32 uBuffSize, UINT32& uRemainSize) const
{
    bool bRet = true;
    UINT32 uPacketSize = calcSize();
    if (uBuffSize < uPacketSize) {
        return false;
    }
    uRemainSize = uBuffSize;
    bRet = MUPProtocol::encode(uPacketSize, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::encode(_tagName, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::encode(_tagID, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    return bRet;
}

bool RtdTag::decode(const void* pDataPtr, UINT32 uDataSize, UINT32& uRemainSize)
{
    bool bRet = true;
    UINT32 uPacketSize = 0;
    uRemainSize = uDataSize;
    bRet = MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, uPacketSize, uRemainSize);
    if (!bRet || (uPacketSize > uDataSize)) {
        return bRet;
    }

    MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, _tagName, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, _tagID, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    uRemainSize = uDataSize - uPacketSize;
    return bRet;
}

UINT32 RtdTag::calcSize() const
{
    UINT32 uRet = sizeof(UINT32);
    uRet += MUPProtocol::getSize(_tagName);
    uRet += MUPProtocol::getSize(_tagID);

    return uRet;
}

RtdValue::RtdValue()
{
}

RtdValue::~RtdValue()
{
}

bool RtdValue::encode(void* pBuffPtr, UINT32 uBuffSize, UINT32& uRemainSize) const
{
    bool bRet = true;
    UINT32 uPacketSize = calcSize();
    if (uBuffSize < uPacketSize) {
        return false;
    }
    uRemainSize = uBuffSize;
    bRet = MUPProtocol::encode(uPacketSize, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::encode(_vt, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::encode(_val, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    return bRet;
}

bool RtdValue::decode(const void* pDataPtr, UINT32 uDataSize, UINT32& uRemainSize)
{
    bool bRet = true;
    UINT32 uPacketSize = 0;
    uRemainSize = uDataSize;
    bRet = MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, uPacketSize, uRemainSize);
    if (!bRet || (uPacketSize > uDataSize)) {
        return bRet;
    }

    MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, _vt, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, _val, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    uRemainSize = uDataSize - uPacketSize;
    return bRet;
}

UINT32 RtdValue::calcSize() const
{
    UINT32 uRet = sizeof(UINT32);
    uRet += MUPProtocol::getSize(_vt);
    uRet += MUPProtocol::getSize(_val);

    return uRet;
}

RtdData::RtdData()
{
}

RtdData::~RtdData()
{
}

bool RtdData::encode(void* pBuffPtr, UINT32 uBuffSize, UINT32& uRemainSize) const
{
    bool bRet = true;
    UINT32 uPacketSize = calcSize();
    if (uBuffSize < uPacketSize) {
        return false;
    }
    uRemainSize = uBuffSize;
    bRet = MUPProtocol::encode(uPacketSize, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::encode(_ownerID, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::encode(_timeStamp, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::encode(_quality, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    _value.encode((char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    return bRet;
}

bool RtdData::decode(const void* pDataPtr, UINT32 uDataSize, UINT32& uRemainSize)
{
    bool bRet = true;
    UINT32 uPacketSize = 0;
    uRemainSize = uDataSize;
    bRet = MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, uPacketSize, uRemainSize);
    if (!bRet || (uPacketSize > uDataSize)) {
        return bRet;
    }

    MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, _ownerID, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, _timeStamp, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, _quality, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    _value.decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    uRemainSize = uDataSize - uPacketSize;
    return bRet;
}

UINT32 RtdData::calcSize() const
{
    UINT32 uRet = sizeof(UINT32);
    uRet += MUPProtocol::getSize(_ownerID);
    uRet += MUPProtocol::getSize(_timeStamp);
    uRet += MUPProtocol::getSize(_quality);
    uRet += _value.calcSize();

    return uRet;
}

RtdDataInfo::RtdDataInfo()
{
}

RtdDataInfo::~RtdDataInfo()
{
}

bool RtdDataInfo::encode(void* pBuffPtr, UINT32 uBuffSize, UINT32& uRemainSize) const
{
    bool bRet = true;
    UINT32 uPacketSize = calcSize();
    if (uBuffSize < uPacketSize) {
        return false;
    }
    uRemainSize = uBuffSize;
    bRet = MUPProtocol::encode(uPacketSize, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    MUPProtocol::encode(_dataVector, (char*)pBuffPtr + uBuffSize - uRemainSize, uRemainSize, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    return bRet;
}

bool RtdDataInfo::decode(const void* pDataPtr, UINT32 uDataSize, UINT32& uRemainSize)
{
    bool bRet = true;
    UINT32 uPacketSize = 0;
    uRemainSize = uDataSize;
    bRet = MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, uPacketSize, uRemainSize);
    if (!bRet || (uPacketSize > uDataSize)) {
        return bRet;
    }

    MUPProtocol::decode((char*)pDataPtr + uDataSize - uRemainSize, uRemainSize, _dataVector, uRemainSize);
    if (!bRet) {
        return bRet;
    }

    uRemainSize = uDataSize - uPacketSize;
    return bRet;
}

UINT32 RtdDataInfo::calcSize() const
{
    UINT32 uRet = sizeof(UINT32);
    uRet += MUPProtocol::getSize(_dataVector);

    return uRet;
}


}

